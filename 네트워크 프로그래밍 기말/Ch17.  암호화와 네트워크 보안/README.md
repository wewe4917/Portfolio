# 네트워크 프로그래밍 기말 정리
## 암호화의 이해
### > 외부 침임자가 전송 메시지에 가하는 공격 행동
- 메시지 읽기
  - 전송 선로에서 흐르는 신호를 도청하여 메시지의 내용응 읽음
- 전송 방해
  - 전송 메시지가 수신자에게 도착하지 못하게 함으로써 송수신자간의 통신을 방해
  - 예) 인터넷에서 방화벽 기능을 통해 불법 사이트에 접속하지 못하도록 차단하는 것과 무선 통신에서 교란 전파를 발사하는 것
- 메시지 수정
  - 전송되는 메시지의 내용을 수정하는 것으로, 송수신자가 교환하는 메시지의 의미를 왜곡

### > 암호화 용어
- 외부 침입자가 송수신자 사이에 젠성되는 메시지를 불법적으로 읽거나 수정하는 등의 위해 행위를 막기 위해 컴퓨터 네트워크에서 사용하는 일반 기법
- **암호화는 메시지의 내용을 임의로 조작하여 원래의 의미를 알아볼 수 없도록 변형하는 작업**
- 암호화된 문서를 원래 언어로 복구하여 수신자가 알아보기 위해서는 해독 과정이 필요
- [그림 17-1]은 왼쪽에서 오른쪽으로 메시지를 전송할 떄 암호화와 해독 과정\
![image](https://user-images.githubusercontent.com/120394200/207134408-f98bd634-c59d-4439-83ee-df4927a4e878.png)

### > **암호키**
- 암호화와 해독 과정에서 키를 사용하며 암호키와 해독키가 있음
- **암호키**는 송신 호스트에서 암호화 알고리즘에 필요한 키
- 해독키는 수신 호스트에서 해독 알고리즘에 필요한 키
- [그림 17-2]의 (a)는 암호화와 해독 과정에서 동일한 하나의 키 k 를 사용하는 대칭키 방식
- (b)는 암호화 과정에서 사용하는 암호키 K(E)와 해독 과정에서 사용하는 해독키K(o)가 서로 다른 비대칭키 방식\
![image](https://user-images.githubusercontent.com/120394200/207135879-245e2cb8-5a34-445c-8be7-bc5217c9bc25.png)

## 대체 암호화
### > 대체 암호화
 - 임의의 문자를 특정한 문자로 대체하는 암호화
 - 예) 시저 암호화, 키워드 암호화, 복수 개의 문자 변환표 방식 등
### > 시저 암호화
 - 줄리어스 시저가 처음 사용했을 것이라는 의미에서 붙은 이름
 - 알파벳 문자를 순차적으로 세 문짜식 오른쪽으로 이동하면서 대체 문자를 사용하는 방식
 - 시저 암호화에서 암호키에 해당하는 문자 변환표\
![image](https://user-images.githubusercontent.com/120394200/207137245-f86ffe87-858d-4d65-80c6-b8bf66cb3cf5.png)
 - [그림 17-3] 문자 변환표를 이용해 'Network technology'를 암호화하면 다음과 같음\
 ![image](https://user-images.githubusercontent.com/120394200/207139819-f04283bd-1da2-402a-916f-b27aadeb18cb.png)
 - 시저 암호화 방식의 장점은 단순함
  - 세 문자 간격으로 이동된 암호키를 쉽게 기억할 수 있으므로 간단한 수작업만으로도 암호문을 작성하고 해독 가능
  - 이런 단순함은 외부 침입자도 쉽게 해독할 수 있어 단점이기도 함
 ### > 키워드 암호화
  - 시저 암호화 방식의 단점을 부분적으로 보안환 대체 암호화
  - 키워드 암호화는 키워드로 지정한 단어를 문자 변환표의 앞줄에 먼저 적고, 키워드로 사용한 문자를 뺀 나머지 문자를 알파벳순으로 기술하는 방식\
![image](https://user-images.githubusercontent.com/120394200/207140274-679acd40-0e37-47e9-96d5-e6d28aecd6d0.png)

### > 복수 개의 문자 변환표
 - 대체 문자 변환표는 하나이므로 침입자가 해독할 가능성이 높음
 - 이를 보완하기 위해 문자 변환표를 둘 이상 사용 가능
 - [그림 17-6]에서 (a)는 홀수 위치에 있는 문자를 암호화하는 데 사용하고, (b)는 짝수 위치에 있는 문자를 암호화하는 데 사용\
![image](https://user-images.githubusercontent.com/120394200/207140761-e54f9089-b46f-4c7a-95df-e40742595d0a.png)
 - [그림 17-6]의 두 가지 대체 문자 변환표를 사용해 ‘NETWORK TECHNOLOGY’를 암호화한 것
![image](https://user-images.githubusercontent.com/120394200/207140863-9bee76bf-ee0e-4534-aa5e-d70899117b5b.png)

## 위치 암호화
### > 위치 암호화
- 문자의 배열 순서를 변경해 암호화
- 각 문자의 모양은 그대로 유지한 채, 문자의 배열 위치를 임의로 변경하여 암호화
  - 예) 컬럼 암호화, 키워드 암호화 등

### > 컬럼 암호화
- 위치 암호화에서 가장 간단한 방식인 컬럼(열) 암호화는 전체 문장을 제한된 길이의 컬럼을 갖는 표에 작성한 후에 컬럼을 기준으로 다시 배치
- 예) 컬럼의 길이가 7인 컬럼 암호화 방식에서 [그림 17-8]의 (a)와 같은 문장
![image](https://user-images.githubusercontent.com/120394200/207141597-2d486d3d-8ef5-47a3-b041-f30b413559e3.png)

### > 키워드 암호화
- 일반적으로 위치 암호화 방식에서는 중복된 문자를 포함하지 않는 임의의 단어를 암호키로 제공하는 키워드 암호화가 사용
- 예) NETWORK라는 단어를 키워드로 사용해 [그림 17-9]와 같이 위치 암호화하는 과정
![image](https://user-images.githubusercontent.com/120394200/207141814-02af3424-3227-47bd-9efe-92a1c513dbc7.png)

## 암호화 시스템
### > DES 알고리즘
- DES 알고리즘은 암호문을 작성할 때 사용하는 암호키와 암호문을 해독할 때 사용하는 해독키가 동일 따라서 이 키는 절대로 외부에 유출되지 않도록 관리해야 함(**비밀키**)
- 양쪽이 동일키를 사용한다고 해서 대칭키라고도 함
- 외부 사용자에게 노출되지 않아야 하는 암호키로 암호화하는 알고리즘을 비공개키 알고리즘이라 함

### > 동작 방식
- DES 알고리즘은 크기가 64비트인 데이터 블록을 32비트씩 둘로 나누어 독립적으로 처리
- 32비트 블록 하나를 암호키로 암호화한 후에, 두 블록의 위치를 맞바꾸는 과정을 16번 반복하는데, 이 과정이 [그림 17-10]의 중간에 표기한 16번의 암호화 과정\
![image](https://user-images.githubusercontent.com/120394200/207150376-3fa1dbf8-b7a4-4608-9411-e5cda388c09c.png)
- 위치 암호화의 중간 단계에는 동일한 암호화 알고리즘을 16번 반복하는데, 각 단계에서 수행하는 기능은 [그림 17-11]\
![image](https://user-images.githubusercontent.com/120394200/207150585-c001b1f3-cdc1-4459-942a-84982f18ee68.png)
### > 3DES 알고리즘
- 3DES는 암호 기능을 강화하기 위하여 세 번의 DES 알고리즘을 수행하는 3단계 DES 알고리즘
- 3DES는 기본적으로 DES 알고리즘을 그대로 사용하기 때문에 구현하기 쉬우며, 기존 DES 시스템을 사용하던 환경에 적용하기 편리
- DES 알고리즘에 비하여 3배 이상 속도가 느리다는 단점이 있음
- 3DES는 3단계 절차를 거쳐 암호화가 이루어지며, 반대의 해독 과정에서도 3단계 절차가 진행\
![image](https://user-images.githubusercontent.com/120394200/207151024-39868e26-cff3-45df-9434-33d513f518d0.png)
- 3DES 알고리즘을 이용한 해독 과정\
![image](https://user-images.githubusercontent.com/120394200/207151152-a191d78b-af50-4a11-b72e-093dda6def8b.png)
- **암호키 사용과 관련해서는 세 가지 옵션이 표준으로 정해져 있음**

![image](https://user-images.githubusercontent.com/120394200/207151617-86417fd6-d3de-4151-9dc7-de4e5d73bbb1.png)

## RSA 알고리즘
- **공개키 알고리즘은 사용자가 2개의 암호키(공개키, 비공개키) 조합을 사용하는데, 공개키는 원문서를 암호화는 데 사용하므로 원친적으로 누구에게나 공개됨**
  - 따라서 송신 호스트는 공개키로 원문서를 암호화하여 전송
- 수신 호스트는 암호문을 해독하기 위해 비공개키를 사용
  - 비공개키는 공개키와 다른 값을 가짐
-공개키 알고리즘의 대표적인 예는 [그림 17-14]의 RSA 알고리즘
![image](https://user-images.githubusercontent.com/120394200/207154014-013a5f20-751c-47c8-a8aa-1430833bd648.png)

## 전자 서명
- 전자 서명은 인터넷 환경에서 특정 사용자를 인증하려고 사용
- 인증은 특정인이 진짜 그 사람인지를 확인하는 절차
- 이와 비슷한 기능으로 권한이 있고 없음을 확인하는 권한(Authorization)이 있는데, 인증과 다른 특징이 있음\
![image](https://user-images.githubusercontent.com/120394200/207154143-19bd58ab-15fb-4625-ba2e-c92f83f26b0e.png)

### > 암호화 과정
- 전자 서명의 암호화는 [그림 17-16]과 같이 2단계로 이루어짐 
  - 첫 번째는 전자 서명 알고리즘으로 자신을 인증하는 비공개키 암호화 단계
  - 두 번째는 전자 서명의 정보를 전송하기 위해 다시 RSA \ 
![image](https://user-images.githubusercontent.com/120394200/207154267-cdfda2b8-a712-4ae2-9484-08a3fe037631.png)

### > 해독 과정
- [그림 17-17]은 수신 호스트가 전자 서명된 문서를 해독하는 과정 \
![image](https://user-images.githubusercontent.com/120394200/207155421-ea02001f-cebe-4968-a37d-a4c9ec7eec8b.png)
- 전자 서명 과정에서 2단계로 암호화하는 이유
  - RSA 알고리즘을 사용해 암호화하는 이유는 전송 과정에서 발생할 수 있는 보안 문제를 해결하기 위함
  - 전자 서명의 기본 목적인 인증 문제를 해결해야 하므로 비공개키인 전자 서명을 사용해 암호화하는 과정도 필요\

## 보안 프로토콜
### > 인터넷은 전 세계적으로 연결된 거대한 통신망으로, 데이터 전달 과정에서 다양한 보안 문제를 직면할 수 있음

### > 감청
- 감청은 허가받지 않은 자가 직간접적인 방법으로 전송 중인 데이터를 얻는 것
- 불법으로 획득한 정보를 변경한 후 이를 통신 과정에 다시 입력함으로써, 송수신 호스트의 통신 내용을 왜곡하는 것도 넓은 의미에서 감청에 포함

### > 암호화
- 전송 선로에서 감청 위협으로부터 데이터를 안전하게 보호하는 방법에는 물리 계층에서 데이터를 송신하기 전에 암호화하는 데이터 링크 계층 암호화가 있음
- [그림 17-18]처럼 응용 계층부터 네트워크 계층까지는 암호화 기능을 수행하지 않으며, 전송 직전인 데이터 링크 계층에서 암호화하는 방식이 데이터 링크 계층 암호화임\
![image](https://user-images.githubusercontent.com/120394200/207158768-395e2f7b-ed67-4729-9978-bd696cb67b1f.png)

### > 호스트 내부에서 보안을 지원하려면 응용계층 암호화 방식을 사용해야함
- 송수신 과정의 끝단에 위치한 응용 계층에서 암호화하는 방식으로, 형태는 다음과 같음
![image](https://user-images.githubusercontent.com/120394200/207159118-48967e45-3cff-428c-bf50-920ee6b2659b.png)

### > 트랙픽 제어
- **특정 호스트가 누구와 통신을 많이 하는지에 대한 정보도 네트워크 보안에 포함**
- 외부 침입자의 통신량 분석을 방해하는 간단한 방법은 무의미한 가공의 데이터를 여러 호스트에서 주기적으로 발생시킴으로써 통계 자료에 혼선을 주는 것
- 이러한 가상 데이터의 통신량, 송신자, 수신자 등은 랜덤하게 생성됨

### > 방화벽
- 개방적인 공중 인터넷망과 제한된 사용자 그룹에 허가된 사설망 사이에 보안 기능이 필요
- 사설망을 외부로부터 보호하는 간단한 방법은 외부망을 끊어버리는 것
  - 사설망의 내부 사용자가 공중 인터넷망에 접속하면서 보안을 유지하려면 [그림 17-20]과 같은 방화벽 기능이 필요
![image](https://user-images.githubusercontent.com/120394200/207160629-4a11a97a-46e6-4f47-ae06-bcf6b5a34154.png)

### > 라우터를 이용한 방화벽 구현
- 인터넷에 연결된 호스트들은 외부 통신망과 연결하기 위해 반드시 라우터의 중개 과정을 거침
- 따라서 라우터를 이용해 방화벽을 구현하는 것은 간단하면서도 효과적
- 라우터는 자신과 연결된 네트워크로부터 입력된 패킷의 정보를 분석하여 어느 네트워크로 중개할 것인지를 결정하므로, 패킷을 계속 전송할지에 대한 권한도 가짐\
![image](https://user-images.githubusercontent.com/120394200/207161145-23360ee7-39ce-4442-a46f-c45cb503d783.png)

### > **프록시를 이용한 방화벽 구현**
- 라우터의 방화벽 기능은 네트워크 계층과 전송 계층의 헤더 정보에 정의된 IP 주소와 포트 번호에 기초하여 이루어짐
  - 그러므로 메일 내용처럼 패킷 내부에 포함되는 응용 데이터는 제어할 수 없음
- 프록시는 응용 환경에서 적절하게 처리할 수 있는 정보만 수신하도록 가상의 응용 프로그램을 시뮬레이션하는 방화벽
- 프록시는 내부 네트워크의 호스트에는 외부 네트워크의 응용 프로그램처럼 보이고, 외부 네트워크에는 내부 네트워크의 응용 프로그램처럼 보임
- [그림 17-22]와 같이 메일 송신자와 수신자 사이에 메일 프록시를 설치
- 메일 수신자는 메일 프록시 내부에 있는 가상 송신자를 메일 송신자로 인식하고, 메일 송신자는 메일 프록시 내부에 있는 가상 수신자를 메일 수신자로 인식하여 SMTP 메시지를 전송 

![image](https://user-images.githubusercontent.com/120394200/207161793-f41c3aba-4f27-4de0-ba39-6c344e536ab8.png)






 















